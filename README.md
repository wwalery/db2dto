# db2dto

Generate advanced DTO Java classes from database

Generated classes based on database metadata (schema) with flexible settings.

Some common settings for generated code:

```json
 "common": {
    "classPrefix": "",
    "classSuffix": "Data",
    "readOnlyFields": ["is_disabled"],
    "packageName": "nurs.db"
  },
```

  * **classPrefix** - class name prefix
  * **classSuffix** - class name suffix
  * **readOnlyFields** - don't generate setters for these columnt
  * **packageName** - name of java package
  * **columnsOrder** - generate columns in this order
    * **ALPHA** - columns sorted by name
    * **TABLE** - order as in table
  * **useDefaults** - Use default column value as initial value from DB in generated classes


You have ability to set specific behavior from global sql types:

```json
  "sqlTypes": {
    "cidr": "String",
    "_cidr": "String",
    "_text": "String",
    "_varchar": "String"
  },
```


```json
 "common": {
    "classPrefix": "",
    "classSuffix": "Data",
    "readOnlyFields": ["is_disabled"],
    "packageName": "nurs.db"
  },
```

to specific tables:

```json
  "tables": {
    "test_table_1": {
      "packageName": "dto.test1",
      "interfaces": ["dev.walgo.db2dto.TestInterface"],
```

And fields:

  * set field name:

```json
      "fieldNames": {
        "real_field_name": "new_name"
      },
```
for example, for interface conformity


  * add fields, not existing in table:

```json
      "additionalFields": {
        "add_field": "Integer"
      },
```

  * additional fields could be:
    * simple types: **int**, **boolean**, etc
    * object types: **Integer**, **String**, etc
    * collections: **Map**, **List** and **Set**
    * complex types - any compile-time reachable from this class, with full package name, e.g: **other.package.BeanClass**
  

  * set fields as enums:

```json
      "enumFields": {
        "enum_field": "dev.walgo.db2dto.TestEnum"
      },
```

  * generate toString method for all fields with exceptions:

```json
      "toStringIgnoreFields": [
        "big_field"
      ],
```


  * set some fields as _readOnly__, i.e. without setters:

```json
      "readOnlyFields": [
        "read_only"
      ]
    },
```

  * set specific default value to field (by field name)

```json
      "fieldDefaults": {
        "test_array": "new ArrayList<String>()"
      }
```

  * set specific default value to specific field type (by sql type)

```json
      "typeDefaults": {
        "timestamptz": "Instant.now()"
      }
```

  * set specific default valuea type to field (by field name)

```json
      "fieldTypes": {
        "test_array": "dev.walgo.db2dto.TestType"
      }
```


It's also possible to compile generated code immediatelly and create separate jar:

```json
{
  ...
  "compile": true,
  "classOutputDir": "build/classes",
  "jarPath": "build/test-db-0.2.4.jar",
```

Code generated by predefined templates (Pebble), so, you have ability to use your own templates.

For code, generated with default templates, you have common interface:

```java
public interface IData {
  // check that file changed
  boolean hasChangedField(final String fieldName);
  
  // Any fields changed
  boolean isChanged();
  void resetChangedField(final String fieldName);
  
  // reset fields changing flag
  void resetChanged();
  
  // return all fields 
  Set<String> getFieldNames();
}
```

and each generated class have for all table fields:

  * ability to set _changed_ flag, e.g:

```java
// status_type
  public StatusTypeData setStatusTypeChanged() {
    changedFields.add("status_type");
    return this;
  }
```

  * ability to check if field changed after last read from DB, e.g:
  
```java
  public boolean isStatusTypeChanged() {
    return changedFields.contains("status_type");
  }
```

  * prudent setters with change field property only when it really changed, e.g:
  

```java
  public StatusTypeData setStatusType(final String newValue) {
    if (!java.util.Objects.equals(newValue, statusType)) {
      this.statusType = newValue;
      changedFields.add("status_type");
    }
    return this;
  }
```

  * additional setters for set only non-null value, e.g:
  
```java
  public StatusTypeData setStatusTypeNotNull(final String newValue) {
    if (!java.util.Objects.equals(newValue, statusType) && (newValue != null)) {
      this.statusType = newValue;
      changedFields.add("status_type");
    }
    return this;
  }
```

  * _changed_ state checker for each field, e.g:
  

```java
  public String getStatusType() {
    return this.statusType;
  }
```

Usage:

  * via command line, e.g.:
```sh
# when all settings in db2dto.conf
java -cp postgresql-42.2.12.jar:db2dto-0.1.0.jar dev.walgo.db2dto.Main
```

```sh
# when you need to set connection data dynamically
java -cp postgresql-42.2.12.jar:db2dto-0.1.0.jar dev.walgo.db2dto.Main --url jdbc:postgresql://localhost/test_db --user testUser --password testPassword
```

dev.walgo.db2dto.Main command line:

    * -c,--config <configFile>     Configuration file.
    * -d,--url <dbUrl>             Database connection string.
    * -h                           This help
    * -p,--password <dbPassword>   Database user password.
    * -s,--schema <dbSchema>       Database schema.
    * -u,--user <dbUser>           Database user name.

For execute generator via command line, you need to download **db2dto-x.y.z.jar** separatelly from the site, or build from the source via ./gradlew shadowJar, or insert all dependencies into classpath.


  * via gradle task:

```groovy
task dto(type: JavaExec) {
  classpath = sourceSets.main.runtimeClasspath
  main = 'dev.walgo.db2dto.Main'
  args '--url', 'jdbc:postgresql://localhost/test_db', '--user', 'testUser', '--password', 'testPassword'
}
```

  * via direct execution - allow to more flexible settings, but slighly harder, because of that you need to add libraries to gradle buildscript's classpath
  
```groovy
task dto() {
  File file = new File('db2dto.conf')
  com.google.gson.Gson gson = new com.google.gson.Gson();
  dev.walgo.db2dto.config.Config config = gson.fromJson(file.text, dev.walgo.db2dto.config.Config.class);
// only for testing..
  config.dbURL = 'jdbc:postgresql://localhost/test_db'
  config.dbUser = 'testUser'
  config.dbPassword = 'testPassword'
  dev.walgo.db2dto.Processor proc = new dev.walgo.db2dto.Processor();
  proc.setConfig(config);
  proc.execute();
} 
`


